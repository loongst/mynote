jid,id,groups,title,description,audit,remediation,references
1.1.1,1.1,主机配置,确保已创建容器的单独分区（Scored）,所有的Docker容器及其数据和元数据都存储在/var/lib/docker目录下。默认情况下，/var/lib/docker目录会根据可用性挂载在/或/var分区下。,在Docker主机上执行以下命令：`grep/var/lib/Docker/etc/fstab `这应该返回/var/lib/Docker挂载点的分区详细信息。,对于新的安装，为/var/lib/docker挂载点创建一个单独的分区。对于先前安装的系统，请使用逻辑卷管理器（LVM）创建分区。,https://www.projectatomic.io/docs/docker-storage-recommendation/
1.2.1,1.2,主机配置,确保容器主机已经加固（Not Scored）,容器运行在Linux主机上。一个容器主机可以运行一个或多个容器。非常重要的是对主机进行加固，以减轻主机安全配置不当所带来的风险。,确保遵守特定于主机的安全准则。询问系统管理员当前主机系统符合哪个安全基准。确保主机系统实际符合特定于主机的安全基准。,您可以考虑为容器主机选择各种CIS安全基准。如果您还需要遵守其他安全指南或监管要求，请根据您的环境选择适当的方案。此外，您可以运行带有grsecurity和PaX的内核。这将添加许多安全检查，包括编译时和运行时。它还旨在打败许多攻击，具有强大的安全功能。这些功能不需要特定于Docker的配置，因为这些安全功能适用于系统范围，而独立于容器。,"https://docs.docker.com/engine/security/security/,https://learn.cisecurity.org/benchmarks,https://docs.docker.com/engine/security/security/#other-kernel-security-features,https://grsecurity.net/,https://en.wikibooks.org/wiki/Grsecurity,https://pax.grsecurity.net/,http://en.wikipedia.org/wiki/PaX"
1.2.2,1.3,主机配置,确保 Docker 已经是最新版本（Not Scored）,Docker软件经常发布更新，修复安全漏洞和产品漏洞，并引入新的功能。请关注这些产品更新，并及时升级，以确保您的组织能够修复新的安全漏洞或采用适当的修复方案。,执行下面的命令，并验证Docker版本是否根据需要是最新的。使用最新版本并不是强制的。,跟踪 Docker 发布情况，并根据需要进行更新。,"https://docs.docker.com/engine/installation/,https://github.com/moby/moby/releases/latest,https://github.com/docker/docker-ce/releases/latest"
1.1.2,1.4,主机配置,确保只有受信任的用户可以控制Docker守护程序（Scored）,Docker守护进程目前需要root权限。将用户添加到docker组中，将赋予他完全的root访问权限。,在docker主机上执行以下命令，并确保只有受信任的用户是docker组的成员：`getent group docker`,请移除不信任的用户从docker用户组中。此外，不要将主机上敏感目录与容器卷进行映射。,"https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface,https://www.andreas-jung.com/contents/on-docker-security-docker-group-considered-harmful,http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/"
1.1.3,1.5,主机配置,确保为 Docker 守护程序配置了审计功能（Scored）,审计所有Docker守护进程的行为。,验证是否存在针对Docker守护进程的审核规则。例如，执行以下命令：`auditctl -l | grep /usr/bin/docker `。这应该列出Docker守护进程的规则。,添加一个Docker守护程序的规则。例如，在/etc/audit/audit.rules文件中添加以下规则： - w /usr/bin/docker -k docker，然后重新启动audit守护程序。例如，service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.5,1.6,主机配置,确保为Docker文件和目录 - /var/lib/docker 配置审计（Scored）,审计 /var/lib/docker。,验证是否有对应于/var/lib/docker目录的审核规则。例如，执行以下命令：`auditctl -l | grep /var/lib/docker`。这应该列出/var/lib/docker目录的规则。,需要为/var/lib/docker目录添加规则。例如，在/etc/audit/audit.rules文件中添加以下行： -w /var/lib/docker -k docker，然后重新启动audit守护程序。例如：service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.6,1.7,主机配置,确保已配置Docker文件和目录的审计- /etc/docker（Scored）,审计 /etc/docker。,验证是否有对应于/etc/docker目录的审核规则。例如，执行以下命令：`auditctl -l | grep /etc/doker`。这应该列出/etc/docker目录的规则。,为/etc/docker目录添加一个规则。例如，在/etc/audit/audit.rules文件中添加以下行：-w /etc/docker -k docker，然后重新启动audit守护进程。例如，service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.7,1.8,主机配置,确保为Docker文件和目录配置了审计 - docker.service（Scored）,若文件存在，请审计docker.service。,步骤1：查找文件位置：`systemctl show -p FragmentPath docker.service`，步骤2：如果文件不存在，则此建议不适用。如果文件存在，请验证是否有对应于该文件的审核规则：例如，执行以下命令：`auditctl -l | grep docker.service`，这应该根据docker.server的位置列出一个规则。,如果文件已存在，为其添加一条规则。例如，在/etc/audit/audit.rules文件中添加以下行：-w /usr/lib/systemd/system/docker.service -k docker，然后重新启动audit守护程序。例如，service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.9,1.9,主机配置,确保针对Docker文件和目录配置审计 - docker.socket（Scored）,若文件存在， 审计 docker.socket。,步骤1：查找文件位置：systemctl show -p FragmentPath dockersocket 步骤2：如果文件不存在，则此建议不适用。如果该文件存在，请验证是否有对应于该文件的审核规则：例如，执行以下命令：auditctl -l |grep docker.socket。这应该根据dockersocket的位置列出一个规则。,如果该文件存在，则为其添加规则。例如，在/etc/audit/audit.rules文件中添加以下行：- w /usr/lib/systemd/system/docker.socket -k docker，然后重新启动audit守护进程。例如，service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.10,1.1,主机配置,确保为Docker文件和目录配置审计 - /etc/default/docker（Scored）,若文件存在，审计/etc/default/docker。,验证是否有对应于/etc/default/docker文件的审核规则。例如，执行以下命令：`auditctl -l | grep /etc/default/docker` 这应该列出 /etc/default/docker 文件的规则。,请为 /etc/default/docker 文件添加一条规则。例如，在 /etc/audit/audit.rules 文件中添加以下行：-w /etc/default/docker -k docker 然后重新启动audit程序。例如，使用命令 service auditd restart。,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html
1.1.11,1.11,主机配置,确保为Docker文件和目录配置审计 - /etc/docker/daemon.json （Scored）,若文件存在，请审计 /etc/docker/daemon.json 文件。,验证是否有对应于/etc/docker/daemon.json文件的审核规则。例如，执行以下命令：`auditctl -l | grep /etc/docker/daemon.json` 这应该列出/etc/docker/daemon.json文件的规则。,在 /etc/docker/daemon.json 文件中添加一条规则。例如，在 /etc/audit/audit.rules 文件中添加以下行：- w /etc/docker/daemon.json -k docker，然后重新启动audit守护进程。例如，输入命令 service auditd restart 重新启动。,"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html,https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file"
,1.12,主机配置,确保为Docker文件和目录设置审计 - /usr/bin/docker-containerd（Scored）,若文件存在，请审计/usr/bin/docker-containerd。,验证是否存在与/usr/bin/docker containerd文件相对应的审核规则。例如，执行以下命令：`auditctl -l | grep /usr/bin/docker-containerd` 这应该列出/usr/bin/docker containerd文件的规则。,请为 /usr/bin/docker-containerd 文件添加一条规则。例如，在 /etc/audit/audit.rules 文件中添加以下行：- w /usr/bin/docker-containerd -k docker，然后重启audit守护程序。例如，service auditd restart。,"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html,https://github.com/docker/docker/pull/20662,https://containerd.tools/"
1.1.18,1.13,主机配置,确保为Docker文件和目录配置审计 - /usr/bin/docker-runc（Scored）,若文件存在，请审计/usr/bin/docker-runc的内容。,验证是否存在与/usr/bin/docker runc文件相对应的审核规则。例如，执行以下命令：`auditctl -l | grep /usr/bin/docker-runc` 这应该列出/usr/bin/docker runc文件的规则。,在/etc/audit/audit.rules文件中添加/usr/bin/docker-runc文件的规则。例如，在文件中添加以下行：-w /usr/bin/docker-runc -k docker。然后，重新启动audit守护进程。例如，执行service auditd restart命令。,"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html,https://github.com/docker/docker/pull/20662,https://containerd.tools/,https://github.com/opencontainers/runc"
2.2,2.1,Docker守护程序配置,确保默认桥接中的容器之间的网络流量受限制（Scored）,默认情况下，在默认网络桥接中，同一主机上的容器之间允许所有网络流量。如果不需要，则应限制所有容器之间的通信。需要通信的特定容器可链接在一起。或者，您可以创建自定义网络，并仅将需要通信的容器加入到该自定义网络中。,"运行以下命令并验证是否已将默认网桥配置为限制容器间通信。
`docker network ls --quiet | xargs docker network inspect --format '{{ .Name }}: {{ .Options }}'`
它应该为默认网桥返回com.docker.network.bridge.enable_icc:false。",以守护程序模式运行Docker，并将--icc=false作为参数传递。例如，运行dockerd --icc=false命令。或者，可以按照Docker文档创建自定义网络，只加入需要通信的容器。如果使用自定义网络，则--icc参数仅适用于默认的Docker桥接网络，因此应采用网络分段的方法。,"https://docs.docker.com/engine/userguide/networking/,https://docs.docker.com/engine/userguide/networking/default_network/container-communication/#communication-between-containers"
2.3,2.2,Docker守护程序配置,"确保日志记录级别设置为""info""（Scored）",将Docker守护进程日志级别设置为info。,"`ps -ef | grep docker` 
 请确保--log级别参数不存在，或者如果存在，则将其设置为info。","请按照以下步骤运行 Docker 守护进程：输入命令 dockerd --log-level=""info""。",https://docs.docker.com/edge/engine/reference/commandline/dockerd/
2.4,2.3,Docker守护程序配置,确保Docker被允许对iptables进行更改（Scored）,Iptables用于在Linux内核中设置、维护和检查IP数据包过滤规则表。允许Docker守护进程对iptables进行更改。,"`ps -ef | grep dockerd` 
 请确保--iptables参数不存在或未设置为false。",请不要使用--iptables=false参数来运行Docker守护进程。例如，不要使用下面的命令来启动Docker守护进程：dockerd --iptables=false。,"https://docs.docker.com/engine/userguide/networking/default_network/containe,https://fralef.me/docker-and-iptables.html"
2.5,2.4,Docker守护程序配置,确保不使用不安全的镜像仓库（Scored）,Docker将私有仓库分为安全和不安全两种类型。默认情况下，仓库被视为安全的。,"运行docker info或执行以下命令，以查明是否使用了任何不安全的仓库：
`ps -ef | grep dockerd`
 请确保--insecure-registry参数不存在。",请不要使用任何不安全的镜像仓库。例如，不要像下面这样启动Docker守护进程：dockerd --insecure-registry 10.1.0.0/16。,https://docs.docker.com/registry/insecure/
2.6,2.5,Docker守护程序配置,确保不使用aufs存储驱动程序（Scored）,请不要将aufs作为您的Docker实例的存储驱动程序。,"执行以下命令并验证aufs是否未用作存储驱动程序 `docker info | grep -e ""^Storage Driver:\s*aufs\s*$"" `以上命令不应返回任何内容。",请不要直接使用aufs作为存储驱动程序。例如，不要像下面这样启动Docker守护进程：dockerd --storage-driver aufs。,"https://docs.docker.com/engine/userguide/storagedriver/selectadriver/#support,https://docs.docker.com/engine/userguide/storagedriver/"
2.7,2.6,Docker守护程序配置,确保已配置 Docker 守护进程的 TLS 身份验证（Scored）,可以让Docker守护进程监听特定的IP和端口，以及除默认Unix套接字以外的任何其他Unix套接字。配置TLS身份验证，通过IP和端口限制对Docker守护进程的访问。,`ps -ef | grep dockerd` 确保存在以下参数：'--tlsverify --tlscacert --tlscert --tlskey',请按照Docker文档或其他参考资料中提到的步骤进行操作。,https://docs.docker.com/engine/security/https/
2.8,2.7,Docker守护程序配置,确保默认的 ulimit 被适当地配置（Not Scored）,在您的环境中，将默认的ulimit选项设置为合适的选项。,`ps -ef | grep dockerd` 确保--default-ulimit参数设置为适当的。,以守护进程模式运行Docker，并传递--default-ulimit参数及相应的限制值适用于您的环境。例如，dockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200。,https://docs.docker.com/edge/engine/reference/commandline/dockerd/#default-ulimits
2.9,2.8,Docker守护程序配置,启用用户命名空间支持（Scored）,在Docker守护进程中启用用户命名空间支持，以利用容器用户到主机用户的重新映射。如果您使用的容器中没有明确定义的容器用户，则此建议很有用。如果您使用的容器映像具有预定义的非root用户，则可以跳过此建议，因为此功能仍处于初期阶段，可能会带来不可预测的问题和复杂性。,"`ps -p $(docker inspect --format='{{ .State.Pid }}' <CONTAINER ID>) -o pid,user` 上面的命令将找到容器的PID，然后列出与容器进程相关联的主机用户。如果容器进程以root身份运行，则此建议不符合要求。 或者，您可以运行`docker info`以确保`userns`在`Security Options`下：`docker info --format '{{ .SecurityOptions }}'`","请查看Docker文档，根据您的需求可以有多种配置方法。由于不同平台可能存在差异，例如在Red Hat上，子UID和子GID映射创建不会自动工作。您可能需要创建自己的映射。 但是，高级步骤如下：

**步骤1：** 确保文件/etc/subuid和/etc/subgid存在。 touch /etc/subuid /etc/subgid 

**步骤2：** 使用--userns-remap标志启动docker守护进程。 dockerd --userns-remap=default","https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-user-namespace-options,http://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf"
2.1,2.9,Docker守护程序配置,确保默认cgroup使用已经确认（Scored）,"其中--cgroup-parent选项允许您设置所有容器使用的默认cgroup父级。如果没有特定的使用情况,则应将此设置保持默认状态。",默认设置足够好，可以保持原样。如果您想专门设置一个非默认的cgroup，请在启动它时将--cgroup参数传递给docker守护进程。例如，`dockerd --cgroup-parent=/foobar`,默认设置已经足够好了，可以保持不变。如果您想要设置一个特定的非默认的cgroup，则在启动docker守护进程时，可以通过--cgroup-parent参数进行设置。例如，dockerd --cgroup-parent=/foobar。,https://docs.docker.com/engine/reference/commandline/dockerd/#default-cgroup-parent
2.11,2.1,Docker守护程序配置,确保基础设备大小在不需要时不要更改（Scored）,在某些情况下，您可能需要容器大小大于10G。在这些情况下，请仔细选择基础设备的大小。,`ps -ef | grep dockerd` 执行上面的命令，它不应该显示任何--storage-opt dm.basesize 参数。,请勿在不需要的情况下设置 --storage-opt dm.basesize。,https://docs.docker.com/engine/reference/commandline/dockerd/#storage-driver-options
2.12,2.11,Docker守护程序配置,确保启用了 Docker 客户端命令的授权 （Scored）,使用原生Docker授权插件或第三方授权机制来管理对Docker客户端命令的访问权限。,`ps -ef | grep dockerd` 如果使用docker本机授权，请确保--authorization插件参数设置适当。 `docker search hello-world`  确保docker守护进程需要授权才能执行上述命令。,步骤1：安装/创建授权插件。步骤2：根据需要配置授权策略。步骤3：按以下方式启动docker守护程序：dockerd --authorization-plugin=<PLUGIN_ID>。,"https://docs.docker.com/engine/reference/commandline/dockerd/#access-authorization,https://docs.docker.com/engine/extend/plugins_authorization/,https://github.com/twistlock/authz"
2.13,2.12,Docker守护程序配置,确保已配置集中式和远程日志记录（Scored）,Docker现在支持各种日志驱动程序。存储日志的首选方式应支持集中式和远程日志记录。,运行docker info并确保Logging Driver属性设置为适当的。`docker info --format '{{ .LoggingDriver }}'` 或者，如果已配置，下面的命令将为您提供--log驱动程序设置。确保设置为适当。 `ps -ef | grep dockerd`,"步骤1：按照文档设置所需的日志驱动程序。 
步骤2：使用该日志驱动程序启动Docker守护程序。例如，dockerd --log-driver=syslog --log-opt syslog-address=tcp://192.xxx.xxx.xxx。",https://docs.docker.com/engine/admin/logging/overview/
,2.13,Docker守护程序配置,确保 docker registry v1 的操作已禁用（Scored）,最新的 Docker registry是v2版。对于v1版本的传统注册表进行的所有操作都应受到限制。,`ps -ef | grep dockerd` 上面的命令应该将--disable-legacy-registry参数传递给docker守护进程的选项。,请执行以下命令启动Docker守护程序：dockerd --disable-legacy-registry。,"https://docs.docker.com/edge/engine/reference/commandline/dockerd/#legacy-registries,https://docs.docker.com/registry/spec/api/,https://the.binbashtheory.com/creating-private-docker-registry-2-0-with-token-authentication-service/,https://blog.docker.com/2015/07/new-tool-v1-registry-docker-trusted-registry-v2-open-source/,http://www.slideshare.net/Docker/docker-registry-v2"
2.15,2.14,Docker守护程序配置,确保已启用实时恢复（Scored）,"其中--live-restore选项使得Docker完全支持无守护进程的容器。它确保Docker在关闭或还原时不停止容器,并在容器重启时正确地重新连接到容器。",运行docker info 并确保Live Restore Enabled属性设置为true。 `docker info --format '{{ .LiveRestoreEnabled }}' ` 或者，运行以下命令并确保使用  --live-restore: `ps -ef | grep dockerd`,以守护进程模式运行Docker，并将--live-restore作为参数传递。例如，dockerd --live-restore。,https://docs.docker.com/engine/admin/live-restore/
2.16,2.15,Docker守护程序配置,确保用户区代理被禁用（Scored）,每当暴露端口时，Docker守护程序会启动用户空间代理服务以进行端口转发。当支持Hairpin NAT时，这个服务通常是多余的并可以禁用。,`ps -ef | grep dockerd`  请确保--userland-proxy参数设置为false。,请以以下方式运行Docker守护进程： dockerd --userland-proxy=false,"https://github.com/docker/docker/issues/14856,https://github.com/docker/docker/issues/22741,https://docs.docker.com/engine/userguide/networking/default_network/binding/"
2.17,2.16,Docker守护程序配置,确保必要时应用守护程序自定义seccomp策略（Not Scored）,如果需要，您可以选择在守护进程级别应用自定义的seccomp配置文件，并覆盖Docker的默认seccomp配置文件。,运行以下命令并查看`Security Options`部分中列出的`seccomp`配置文件。如果它是默认的，那意味着Docker的默认seccomp配置文件将被应用。`docker info --format '{{ .SecurityOptions }}'`,默认情况下，Docker应用的是默认的seccomp配置文件。如果这符合你的环境要求，无需采取任何措施。或者，你可以选择应用自己的seccomp配置文件，在守护进程启动时使用--seccomp-profile标志或将其放入守护进程运行时参数文件中。 dockerd --seccomp-profile </path/to/seccomp/profile>。,"https://docs.docker.com/engine/security/seccomp/,https://github.com/docker/docker/pull/26276"
2.18,2.17,Docker守护程序配置,确保在生产环境中避免使用实验性功能（Scored）,在生产环境中要避免使用实验性功能。,运行以下命令，并确保在Server部分中将Experimental属性设置为false。 `docker version --format '{{ .Server.Experimental }}'`,请勿将--experimental作为运行时参数传递给docker守护程序。,https://docs.docker.com/edge/engine/reference/commandline/dockerd/#options
2.14,2.18,Docker守护程序配置,确保容器被限制不获取新权限 （Scored）,默认情况下，限制容器通过suid或sgid位获得额外权限。,`ps -ef | grep dockerd` 请确保-no-new-privileges参数存在并且未设置为false。,请按照以下方式启动Docker守护进程：dockerd --no-new-privileges,"https://github.com/moby/moby/pull/29984,https://github.com/moby/moby/pull/20727"
3.1,3.1,Docker守护进程配置文件,确保docker.service文件的所有权设置为root:root（Scored）,请核实docker.service文件的所有权和组所有权是否正确设置为root。,步骤1:查找文件位置：`systemctl show -p FragmentPath docker.service` 步骤2：如果文件不存在，则此建议不适用。如果文件存在，请使用正确的文件路径执行以下命令，以验证文件是否由root拥有和组拥有。例如，`stat -c %U:%G /usr/lib/systemd/system/docker.service | grep -v root:root`以上命令不应返回任何内容。,"步骤1：查找文件位置：systemctl show -p FragmentPath docker.service 
步骤2：如果文件不存在，则无需执行此建议。如果文件存在，请使用正确的文件路径执行以下命令，将文件所有权和组所有权设置为root。例如，chown root：root /usr/lib/systemd/system/docker.service。",https://docs.docker.com/engine/admin/systemd/
3.2,3.2,Docker守护进程配置文件,确保docker.service文件的权限设置为644或更高限制 （Scored）,请确认docker.service 文件的权限设置为644或更严格。,步骤1:查找文件位置：`systemctl show -p FragmentPath docker.service`步骤2: 如果文件不存在，则此建议不适用。如果文件存在，请使用正确的文件路径执行以下命令，以验证文件权限是否设置为644或更严格。例如，`stat -c %a /usr/lib/systemd/system/docker.service`,"步骤 1：找到文件所在位置：systemctl show -p FragmentPath docker.service

步骤 2：如果文件不存在，则此建议不适用。如果文件存在，则请使用正确的文件路径执行以下命令，将文件权限设置为 644。例如，chmod 644 /usr/lib/systemd/system/docker.service。",https://docs.docker.com/articles/systemd/
3.3,3.3,Docker守护进程配置文件,确保docker.socket文件的所有权设置为root:root（Scored）,请确认docker.socket文件的所有者和组所有权已正确设置为root。,步骤1:查找文件位置：`systemctl show -p FragmentPath docker.socket`步骤2:如果该文件不存在，则此建议不适用。如果该文件存在，请使用正确的文件路径执行以下命令，以验证该文件是否由root拥有和组拥有。例如，`stat -c %U:%G /usr/lib/systemd/system/docker.socket | grep -v root:root`上述命令不应返回任何东西。,"步骤一：查找文件的位置：systemctl show -p FragmentPath docker.socket  
步骤二：如果文件不存在，则此建议不适用。如果文件存在，则使用正确的文件路径执行以下命令，将文件的所有权和组所有权设置为root。例如，chown root:root /usr/lib/systemd/system/docker.socket。","https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option,https://github.com/docker/docker-ce/blob/master/components/packaging/deb/systemd/docker.socket"
3.4,3.4,Docker守护进程配置文件,确保 docker.socket 文件的权限设置为 644 或更严格的权限（Scored）,请确认 docker.socket 文件的权限设置正确，应为 644 或更高权限。,步骤1:查找文件位置：`systemctl show -p FragmentPath docker.socket`步骤2:如果文件不存在，则此建议不适用。如果文件存在，请使用正确的文件路径执行以下命令，以验证文件权限是否设置为644或更严格。例如，`stat -c %a /usr/lib/systemd/system/docker.socket`,"步骤1：找到文件位置：systemctl show -p FragmentPath docker.socket

步骤2：如果文件不存在，则无需执行此步骤。如果文件存在，请使用正确的文件路径执行以下命令将文件权限设置为644。例如，chmod 644 /usr/lib/systemd/system/docker.socket。","https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket,https://github.com/YungSang/fedora-atomic-packer/blob/master/oem/docker.socket,http://daviddaeschler.com/2014/12/14/centos-7rhel-7-and-docker-containers-on-boot/"
3.5,3.5,Docker守护进程配置文件,确保 /etc/docker 目录所有权设置为 root:root（Scored）,请确认 /etc/docker 目录的所有权和组所有权已正确设置为 root。,执行以下命令以验证目录是否为root所有和组所有：`stat -c %U:%G /etc/docker | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root /etc/docker  这条命令的作用是将目录的所有者和组所有者设置为root。,https://docs.docker.com/engine/security/https/
3.6,3.6,Docker守护进程配置文件,确保/etc/docker目录的权限设置为755或更高（Scored）,验证 /etc/docker 目录权限是否正确设置为755或更加严格的权限。,执行以下命令以验证目录是否具有755或更严格的权限：`stat -c %a /etc/docker`,执行 chmod 755 /etc/docker 这会将目录的权限设置为755。,https://docs.docker.com/engine/security/https/
3.7,3.7,Docker守护进程配置文件,确保注册表证书文件的所有权已设置为root:root（Scored）,请确认所有注册表证书文件(通常位于/etc/docker/certs.d/<registry-name>目录下)的所有者和群组都是root。,执行以下命令以验证注册表证书文件是否由root拥有和组拥有：`stat -c %U:%G /etc/docker/certs.d/* | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root /etc/docker/certs.d/<registry-name>/*  这条命令的作用是将存储在/etc/docker/certs.d/<registry-name>目录下的注册表证书文件的所有权和组所有权设置为root用户。,https://docs.docker.com/registry/insecure/
3.8,3.8,Docker守护进程配置文件,请确保注册表证书文件的权限设置为444或更加限制性的权限（Scored）,请确认所有的注册表证书文件（通常在 /etc/docker/certs.d/<registry-name> 目录下）的权限为444或更加严格。,执行以下命令以验证仓库证书文件是否具有444或更严格的权限：`stat -c %a /etc/docker/certs.d/<registry-name>/*`,运行 chmod 444 /etc/docker/certs.d/<registry-name>/*  这条命令的作用是将注册表证书文件的权限设置为444。,https://docs.docker.com/registry/insecure/
3.9,3.9,Docker守护进程配置文件,请确保TLS CA证书文件的所有权被设置为root:root（Scored）,请验证TLS CA证书文件（与--tlscacert参数一起传递的文件）是否由root拥有并归属于root组。,“执行以下命令以验证TLS CA证书文件是否由root拥有和组拥有：`stat -c %U:%G <path to TLS CA certificate file> | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root <path to TLS CA certificate file> 这个命令的作用是将TLS CA证书文件的所有权和组所有权设置为root。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.1,3.1,Docker守护进程配置文件,确保TLS CA证书文件的权限设置为444或更严格（Scored）,请确认 TLS CA 证书文件（在 --tlscacert 参数中传递的文件）具有 444 或更严格的权限。,执行以下命令以验证TLS CA证书文件是否具有444或更严格的权限：`stat -c %a <path to TLS CA certificate file>`,运行 chmod 444 <path to TLS CA certificate file> 此命令将TLS CA证书文件的文件权限设置为444。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.11,3.11,Docker守护进程配置文件,确保 Docker 服务证书文件的所有权被设置为 root:root（Scored）,请验证Docker服务器证书文件（与--tlscert参数一起传递的文件）是否由root用户拥有并且所属组也是root。,执行以下命令以验证Docker服务器证书文件是否由root拥有和组拥有：`stat -c %U:%G <path to Docker server certificate file> | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root <path to Docker server certificate file>  这条指令将Docker服务器证书文件的所有权和组所有权设置为root。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.12,3.12,Docker守护进程配置文件,确保Docker服务器证书文件的权限设置为444或更严格（Scored）,请核实Docker服务器证书文件（通过--tlscert参数传递的文件）是否具有444或更严格的权限。,执行以下命令以验证Docker服务器证书文件是否具有444或更严格的权限：`stat -c %a <path to Docker server certificate file>`,运行 chmod 444 <path to Docker server certificate file>  这条命令的作用是将 Docker 服务器证书文件的文件权限设置为 444。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.13,3.13,Docker守护进程配置文件,确保 Docker 服务器证书密钥文件的所有权设置为root:root（Scored）,请确认Docker服务器证书密钥文件（通过--tlskey参数传递的文件）的拥有者和所属组都是root。,执行以下命令以验证Docker服务器证书密钥文件是否为root所有和group所有: `stat -c %U:%G <path to Docker server certificate key file> | grep -v root:root` 上述命令不应返回任何内容。,运行 chown root:root <path to Docker server certificate key file>  此命令将 Docker 服务器证书密钥文件的所有权和所属组设置为 root。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.14,3.14,Docker守护进程配置文件,确保Docker服务器证书密钥文件的权限设置为400（Scored）,请确认Docker服务器证书密钥文件（通过--tlskey参数传递的文件）拥有400权限。,执行以下命令以验证Docker服务器证书密钥文件是否具有400的权限：`stat -c %a <path to Docker server certificate key file>`,运行 chmod 400 <path to Docker server certificate key file> 这条命令是将Docker服务器证书密钥文件的权限设置为400。请执行该命令。,"https://docs.docker.com/registry/insecure/,https://docs.docker.com/engine/security/https/"
3.15,3.15,Docker守护进程配置文件,确保Docker套接字文件的所有权设置为root:docker（Scored）,请确认Docker套接字文件的所有者为root，组所有者为docker。,执行以下命令以验证Docker套接字文件是否由root和Docker拥有的组所有：`stat -c %U:%G /var/run/docker.sock | grep -v root:docker`以上命令不应返回任何内容。,运行 chown root:docker /var/run/docker.sock 这条命令的作用是将默认Docker套接字文件的所有权设置为root，组所有权设置为docker。,"https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option,https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket"
3.16,3.16,Docker守护进程配置文件,确保Docker套接字文件的权限设置为660或更高限制（Scored）,请确认Docker套接字文件具有660或更高权限限制。,执行以下命令以验证Docker套接字文件是否具有660或更严格的权限：`stat -c %a /var/run/docker.sock`,运行 chmod 660 /var/run/docker.sock 这将把Docker套接字文件的文件权限设置为660。,"https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option,https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket"
3.17,3.17,Docker守护进程配置文件,确保 daemon.json 文件的所有权设置为 root:root（Scored）,请确认 daemon.json 文件的所有权和组所有权是否正确设置为 root。,执行以下命令以验证文件是否为root所有和组所有：`stat -c %U:%G /etc/docker/daemon.json | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root /etc/docker/daemon.json 这个命令将会把文件的所有权和组的所有权设置为root。,https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file
3.18,3.18,Docker守护进程配置文件,确保daemon.json文件的权限设置为644或更严格（Scored）,请确认守护进程的 daemon.json 文件权限已正确设置为 644 或更加严格。,执行以下命令以验证文件权限是否正确设置为644或更严格：`stat -c %a /etc/docker/daemon.json`,运行 chmod 644 /etc/docker/daemon.json 这将把文件权限设置为644，该文件位于/etc/docker/daemon.json。,https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file
3.19,3.19,Docker守护进程配置文件,确保/etc/default/docker文件的所有权设置为root:root（Scored）,请确认 /etc/default/docker 文件的所有权和组所有权已正确设置为 root。,执行以下命令以验证文件是否由root拥有和组拥有：`stat -c %U:%G /etc/default/docker | grep -v root:root`以上命令不应返回任何内容。,运行 chown root:root /etc/default/docker 这将为文件设置所有权和组所有权为root。,https://docs.docker.com/engine/admin/configuring/
3.2,3.2,Docker守护进程配置文件,确保 /etc/default/docker 文件权限设置为 644 或更高级别（Scored）,请确认 /etc/default/docker 文件的权限被正确设置为 644 或更加严格的权限。,执行以下命令以验证文件权限是否正确设置为644或更严格：`stat -c %a /etc/default/docker`,运行 chmod 644 /etc/default/docker 这条命令会将/etc/default/docker文件的权限设置为644。,https://docs.docker.com/engine/admin/configuring/
4.1,4.1,容器镜像和构建文件,确保为容器创建了一个用户（Scored）,在Dockerfile中为容器创建一个非root的用户。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: User={{ .Config.User }}'` 上面的命令应该返回容器用户名或用户ID。如果为空，则表示容器以root身份运行。,"请确保容器镜像的 Dockerfile 包含以下指令：`USER <用户名或 ID>`，其中用户名或 ID 指的是可以在容器基础镜像中找到的用户。如果容器基础镜像中没有特定的用户，则需要在 `USER` 指令之前添加 `useradd` 命令来添加特定用户。例如，可以在 Dockerfile 中添加以下代码来创建容器中的用户：
```
RUN useradd -d /home/username -m -s /bin/bash username
USER username
```
**注意：** 如果镜像中存在容器不需要的用户，请考虑删除它们。删除这些用户后，请提交镜像，然后生成新的容器实例以供使用。","https://github.com/docker/docker/issues/2918,https://github.com/docker/docker/pull/4572,https://github.com/docker/docker/issues/7906"
4.2,4.2,容器镜像和构建文件,确保容器使用受信任的基础镜像（Not Scored）,请确保容器镜像是从零开始写的，或者基于通过安全通道下载的其他已建立和信任的基础镜像。,步骤1-通过执行以下命令检查Docker主机是否使用Docker映像：`Docker images`这将列出Docker主机上当前可用的所有容器映像。采访系统管理员，并获得证据，证明镜像列表是通过安全通道从受信任的来源或从受信任、安全的私人Docker注册表获得的。步骤2-对于在Docker主机上找到的每个Docker映像，检查映像的构建方式，以验证是否来自可信来源和强化配置：`Docker history <imageName>`,#NAME?,"https://titanous.com/posts/docker-insecurity,https://registry.hub.docker.com/,https://github.com/docker/docker/issues/8093,https://docs.docker.com/engine/reference/commandline/pull/,https://github.com/docker/docker/pull/11109,https://blog.docker.com/2015/11/docker-trusted-registry-1-4"
4.3,4.3,容器镜像和构建文件,确保容器中没有安装不必要的软件包（Not Scored）,容器往往是操作系统的精简版本，不要安装与容器的目的无关的任何内容。,步骤1：通过执行以下命令列出容器的所有运行实例：`docker ps -quiet`步骤2：对于每个容器实例，执行以下或等效命令：`docker exec $INSTANCE_ID rpm -qa`。上面的命令将列出容器上安装的程序包。审查清单并确保其合法性。,首先，不要在容器中安装与目的无关的任何东西。如果镜像中有一些您的容器不使用的软件包，请将它们卸载。 如果可能的话，考虑使用最小的基础镜像，而不是标准的Redhat / Centos / Debian镜像。一些选项包括BusyBox和Alpine。这不仅可以将镜像大小从>150Mb减小到约20 Mb，而且特权升级的工具和路径也更少。您甚至可以在leaf / production容器的最终强化措施中删除软件包安装程序。,"https://docs.docker.com/userguide/dockerimages/,https://github.com/progrium/busybox,https://github.com/progrium/busybox"
4.4,4.4,容器镜像和构建文件,确保镜像得到扫描并重新构建，包括安全补丁（Not Scored）,应定期扫描镜像以查找任何漏洞。重新构建镜像以包含补丁，然后从中实例化新容器。,步骤1：通过执行以下命令列出容器的所有运行实例：`docker ps --quiet` 步骤2：对于每个容器实例，执行以下或等效命令以查找容器中安装的包的列表。确保安装了各种受影响包的安全更新。`docker exec $INSTANCE_ID rpm -qa` 或者，您可以运行映像漏洞y扫描工具，可以扫描生态系统中的所有镜像，然后根据您的补丁管理程序为检测到的漏洞应用补丁。,"按以下步骤进行安全补丁程序的镜像重建：

**步骤1**：拉取所有基础镜像（即，给定您的Dockerfile集，提取所有在FROM指令中声明的镜像，并重新拉取它们以检查是否有更新/修补版本）也要在镜像中修补软件包。Docker pull

**步骤2**：强制重建每个镜像：docker build --no-cache

**步骤3**：使用更新后的镜像重新启动所有容器。您还可以在Dockerfile中使用ONBUILD指令，触发用作基础镜像的特定更新指令。","https://docs.docker.com/userguide/dockerimages/,https://docs.docker.com/docker-cloud/builds/image-scan/,https://blog.docker.com/2016/05/docker-security-scanning/,https://docs.docker.com/engine/reference/builder/#/onbuild"
4.5,4.5,容器镜像和构建文件,确保 Docker 的内容信任功能已启用（Scored）,内容可信任度默认情况下是被禁用的。您应该启用它。,`echo $DOCKER_CONTENT_TRUST` 应该返回 1 ,为了在Bash shell中启用内容信任，请输入以下命令：export DOCKER_CONTENT_TRUST=1。或者，在您的配置文件中设置此环境变量，以便在每次登录时启用内容信任。,"https://docs.docker.com/engine/security/trust/content_trust/,https://docs.docker.com/engine/reference/commandline/cli/#notary,https://docs.docker.com/engine/reference/commandline/cli/#environment-variables"
4.6,4.6,容器镜像和构建文件,确保在容器镜像中已添加HEALTHCHECK指令（Scored）,在您的Docker容器映像中添加HEALTHCHECK指令，以在运行容器上执行健康检查。,运行以下命令，并确保docker映像设置了适当的HEALTHCHECK指令`docker inspect --format='{{ .Config.Healthcheck }}' <IMAGE>`,请遵循Docker文档，使用HEALTHCHECK指令重新构建您的容器镜像。,https://docs.docker.com/engine/reference/builder/#healthcheck
4.7,4.7,容器镜像和构建文件,请确保Dockerfile中不独立使用更新指令（Not Scored）,请勿在Dockerfile中单独或单行使用像apt-get update之类的更新指令。,步骤1:运行以下命令以获取镜像列表：`docker images` 步骤2:对上面列表中的每个镜像运行以下命令，并查找单行中的任何更新指令：`docker history <Image_ID>`或者，如果您可以访问该镜像的Dockerfile，请验证是否没有如上所述的更新指令。,在安装软件包时，请使用更新说明和安装说明（或任何其他说明）以及版本锁定，以获取所需版本并打破缓存。 或者，您可以在 Docker 构建过程中使用 --no-cache 标志，以避免使用缓存的层。,"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run,https://github.com/docker/docker/issues/3313"
4.8,4.8,容器镜像和构建文件,请确保镜像中的setuid和setgid权限已被删除（Not Scored）,从镜像中移除setuid和setgid权限可以防止特权升级攻击在容器中发生。,对映像运行以下命令以列出具有setuid和setgid权限的可执行文件：`docker run <Image_ID> find / -perm +6000 -type f -exec ls -ld {} \; 2> /dev/null`仔细检查列表，确保它是合法的。,只允许对需要的可执行文件设置setuid和setgid权限。您可以在构建时通过在Dockerfile中添加以下命令来删除这些权限，最好在Dockerfile的末尾：RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true。, 
4.9,4.9,容器镜像和构建文件,请在Dockerfile中使用COPY代替ADD（Not Scored）,在Dockerfile中使用COPY指令，而不是ADD指令。,步骤1：运行以下命令以获取镜像列表：`docker images`步骤2：对上面列表中的每个镜像运行以下命令，并查找任何ADD指令：`docker history <Image_ID>`或者，如果您可以访问该镜像的Dockerfile，请验证是否没有ADD指令。,在 Dockerfile 中使用 COPY 指令。,https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy
4.1,4.1,容器镜像和构建文件,请确保不将秘密信息存储在Docker文件中（Not Scored）,请勿在Dockerfiles中存储任何机密信息。,第1步：运行以下命令以获取镜像列表：`docker images` 第2步：对上面列表中的每个镜像运行以下命令，并查找任何机密：`docker history <Image_ID>`。或者，如果您有权访问该镜像的Dockerfile，请验证是否没有上述机密。,请勿在Dockerfile中存储任何类型的机密信息。,"https://github.com/docker/docker/issues/13490,https://avicoder.me/2016/07/22/Twitter-Vine-Source-code-dump/"
4.11,4.11,容器镜像和构建文件,确保只安装经过验证的软件包（Not Scored）,在安装镜像中的软件包之前，请验证其真实性。,步骤1：运行以下命令以获取镜像列表：`docker images` 步骤2：对上面列表中的每个镜像运行以下命令，并查看如何确定包的真实性。这可以通过使用GPG密钥或其他安全包分发机制： `docker history <Image_ID>`。或者，如果您可以访问该镜像的Dockerfile，验证检查包的可靠性。,请使用GPG密钥下载和验证软件包，或者选择任何其他安全的软件包分发机制。,"http://www.oreilly.com/webops-perf/free/files/docker-security.pdf,https://github.com/docker-library/httpd/blob/12bf8c8883340c98b3988a7bade8ef2d0d6dcf8a/2.4/Dockerfile,https://github.com/docker-library/php/blob/d8a4ccf4d620ec866d5b42335b699742df08c5f0/7.0/alpine/Dockerfile,https://access.redhat.com/security/team/key"
5.1,5.1,容器运行时,确保启用了 AppArmor 程序配置文件（Scored）,AppArmor 是一个高效且易于使用的 Linux 应用程序安全系统。它在许多 Linux 发行版中默认可用，如 Debian 和 Ubuntu。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: AppArmorProfile={{ .AppArmorProfile }}'` 上面的命令应该为每个容器实例返回一个有效的AppArmor配置文件。,"如果你的Linux操作系统支持AppArmor，建议使用它。你可能需要执行以下步骤：

1.确认是否已安装AppArmor。如果没有，请安装。

2.创建或导入适用于Docker容器的AppArmor配置文件。

3.将该配置文件设置为强制模式。

4.使用自定义的AppArmor配置文件启动Docker容器。例如：docker run --interactive --tty --security-opt=""apparmor:PROFILENAME"" centos /bin/bash，或者你也可以保留Docker的默认AppArmor配置文件。","https://docs.docker.com/engine/security/apparmor/,https://docs.docker.com/engine/reference/run/#security-configuration,https://docs.docker.com/engine/security/security/#other-kernel-security-features"
5.2,5.2,容器运行时,确保已设置 SELinux 安全选项如果 SELinux 存在（Scored）,SELinux是一种有效且易于使用的Linux应用程序安全系统。它默认可用于许多Linux发行版，如Red Hat和Fedora。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'` 上面的命令应该返回当前为容器配置的所有安全选项。,如果您的Linux操作系统适用于SELinux，请使用它。您可能需要遵循以下步骤：1.设置SELinux状态。2.设置SELinux策略。3.创建或导入Docker容器的SELinux策略模板。4.使用启用SELinux的守护程序模式启动Docker。例如，docker daemon --selinux-enabled。5.使用安全选项启动Docker容器。例如，docker run --interactive --tty --security-opt label=level:TopSecret centos /bin/bash。,"https://docs.docker.com/engine/security/security/#other-kernel-security-features,https://docs.docker.com/engine/reference/run/#security-configuration,https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/container_security_guide/docker_selinux_security_policy"
5.3,5.3,容器运行时,确保容器中限制了 Linux 内核的功能 （Scored）,默认情况下，Docker会以一组受限制的Linux内核特权启动容器，这意味着任何进程可以被授予所需的特权，而不必使用root访问。通过使用Linux内核特权，进程不需要以root身份运行，即使在通常需要root权限的大多数特定区域。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CapAdd={{ .HostConfig.CapAdd }} CapDrop={{ .HostConfig.CapDrop }}'` 验证添加和删除的Linux内核功能是否与每个容器实例的容器进程所需的功能一致。,"执行以下命令以添加所需的能力：
> docker run --cap-add={""Capability 1"",""Capability 2""} 

例如，执行以下命令：
docker run --interactive --tty --cap-add={""NET_ADMIN"",""SYS_ADMIN""} centos:latest /bin/bash 

执行以下命令以删除不需要的能力：
> docker run --cap-drop={""Capability 1"",""Capability 2""} 

例如，执行以下命令：
docker run --interactive --tty --cap-drop={""SETUID"",""SETGID""} centos:latest /bin/bash 

或者，您也可以选择删除所有能力，并仅添加所需的能力：
> docker run --cap-drop=all --cap-add={""Capability 1"",""Capability 2""} 

例如，执行以下命令：
docker run --interactive --tty --cap-drop=all --cap- add={""NET_ADMIN"",""SYS_ADMIN""} centos:latest /bin/bash",https://docs.docker.com/engine/security/security/#linux-kernel-capabilities
5.4,5.4,容器运行时,确保不使用特权容器（Scored）,使用 --privileged 参数会将所有Linux内核功能授予容器，从而覆盖 --cap-add 和 --cap-drop 参数。确保不要使用该参数。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Privileged={{ .HostConfig.Privileged }}'` 上面的命令应该为每个容器实例返回Privileged=false。,请勿使用--privileged标志运行容器。例如，不要像下面这样启动容器：docker run --interactive --tty --privileged centos /bin/bash。,https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities
5.5,5.5,容器运行时,确保敏感主机系统目录未挂载到容器中 （Scored）,敏感的主机系统目录，例如以下目录，不应在容器中以读写模式挂载为卷。/ /boot /dev /etc /lib /proc /sys /usr。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}'` 上面的命令将返回当前映射目录的列表，以及是否以读写模式为每个容器实例装载这些目录。,请勿将敏感目录挂载到容器中，特别是在读写模式下。,https://docs.docker.com/engine/tutorials/dockervolumes/
5.6,5.6,容器运行时,确保容器中不运行ssh（Scored）,容器内不应该运行SSH服务器。您应该通过SSH登录Docker宿主机，并使用工具如nsenter，从远程主机进入容器。,步骤1：通过执行以下命令列出容器的所有运行实例：`docker ps --quiet` 步骤2：对于每个容器实例，执行以下命令：`docker exec $INSTANCE_ID ps -el`确保SSH服务器没有进程。,从容器中卸载SSH服务器，并使用nsenter或任何其他命令，例如docker exec或docker attach与容器实例进行交互。 docker exec --interactive --tty $INSTANCE_ID sh OR docker attach $INSTANCE_ID。, 
5.7,5.7,容器运行时,确保特权端口没有映射在容器中（Scored）,TCP/IP端口号在1024以下被视为特权端口。出于各种安全原因，普通用户和进程不被允许使用这些端口。Docker允许将容器端口映射到特权端口。,通过执行以下命令列出所有正在运行的容器实例及其端口映射：`docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'` 查看列表，确保容器端口未映射到1024以下的主机端口号。,在启动容器时，不要将容器端口映射到特权主机端口。此外，请确保Dockerfile中没有容器到主机特权端口映射声明。,https://docs.docker.com/engine/userguide/networking/
5.8,5.8,容器运行时,确保容器上只开放所需的端口（Scored）,一个容器镜像的Dockerfile定义了一个容器实例默认开放的端口。这个端口列表对你在容器内部运行的应用程序可能是相关的，也可能不相关。,通过执行以下命令，列出容器的所有正在运行的实例及其端口映射：`docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'` 查看列表，确保映射的端口是容器真正需要的端口。,请修正容器镜像的Dockerfile，仅暴露所需的端口，避免使用-P（大写）或--publish-all标志，从而完全忽略Dockerfile中定义的端口列表。使用小写的-p或--publish标志显式定义特定容器实例所需的端口。例如，docker run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash。,https://docs.docker.com/engine/userguide/networking/
5.9,5.9,容器运行时,确保主机的网络命名空间未共享（Scored）,当容器的网络模式设置为--net=host时，容器的网络不会被隔离。换言之，这意味着Docker不会将容器的网络容器化。这意味着容器的网络独立于主Docker宿主机之外，并且可以完全访问主机的网络接口。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: NetworkMode={{ .HostConfig.NetworkMode }}'` 如果上面的命令返回NetworkMode=host，则表示在容器启动时传递了--net=host选项，这是不合规的。,启动容器时不要使用--net=host选项。,"https://docs.docker.com/engine/userguide/networking/,https://docs.docker.com/engine/reference/run/#network-settings"
5.1,5.1,容器运行时,确保容器的内存使用量受到限制（Scored）,默认情况下，Docker主机上的所有容器共享资源。通过使用Docker主机的资源管理功能，例如内存限制，您可以控制容器可以消耗的内存量。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Memory={{ .HostConfig.Memory }}'` 如果上面的命令返回0，则表示内存限制不合理。如果上面的命令返回一个非零值，则表示内存限制已配置。,请尽可能减少容器使用的内存。一定要使用--memory参数来启动容器。例如，您可以按照以下方式启动容器：docker run --interactive --tty --memory 256m centos /bin/bash。在上述示例中，容器的内存限制为256 MB。注意：如果有内存限制，下面的命令的输出将返回科学计数法的值。 docker inspect --format='{{.Config.Memory}}' 7c5a2d4c7fe0。例如，如果上述容器实例的内存限制为256 MB，则上述命令的输出将为2.68435456e+08而不是256m。您应该使用科学计算器或编程方法将此值转换为实际值。,"https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/,https://docs.docker.com/engine/reference/commandline/run/#options,https://docs.docker.com/engine/admin/runmetrics/"
5.11,5.11,容器运行时,确保容器的CPU优先级设置适当（Scored）,默认情况下，Docker主机上的所有容器共享资源。通过使用Docker主机的资源管理功能（例如CPU份额），您可以控制容器可以使用的主机CPU资源。这样可以更好地管理和优化主机上的资源分配。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CpuShares={{ .HostConfig.CpuShares }}'` 如果上面的命令返回0或1024，则表示CPU共享配置不合理。如果上述命令返回1024以外的非零值，则表示CPU共享已合理配置。,管理容器之间的CPU份额。为此，您可以使用--cpu-shares参数启动容器。例如，您可以像下面这样运行一个容器：docker run --interactive --tty --cpu-shares 512 centos /bin/bash。在上面的示例中，容器以其他容器使用CPU份额的50%启动。因此，如果其他容器的CPU份额为80％，则此容器的CPU份额为40％。 注意：每个新容器默认情况下都会有1024个CPU份额。但是，如果运行审计部分中提到的命令，则此值将显示为0。   或者， 1. 导航到/sys/fs/cgroup/cpu/system.slice/目录。 2. 使用docker ps检查容器实例ID。 3. 现在，在上述目录（步骤1中）内，您将拥有一个名称为docker- <Instance ID> .scope的目录。例如，docker- 4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope。转到此目录。 4. 您将找到一个名为cpu.shares的文件。执行cat cpu.shares。这总是基于系统给出CPU份额的值。因此，即使没有使用-d或--cpu-shares参数在docker run命令中配置CPU份额，此文件也将具有值1024。 如果我们将一个容器的CPU份额设置为512，则它将获得其他容器的CPU时间的一半。因此，将1024视为100％，然后进行快速计算，以推导出应为各自的CPU份额设置多少。例如，使用512如果要设置50％，使用256如果要设置25％。,"https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/,https://docs.docker.com/engine/reference/commandline/run/#options,https://docs.docker.com/engine/admin/runmetrics/"
5.12,5.12,容器运行时,确保容器的根文件系统已以只读方式挂载（Scored）,使用Docker运行命令时，应当使用--read-only选项将容器的根文件系统视为“黄金镜像”。这样可以防止容器运行时对根文件系统进行任何写操作，并强制实施不变基础设施的原则。,在docker主机上运行以下命令：`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: ReadonlyRootfs={{ .HostConfig.ReadonlyRootfs }}'` 如果上面的命令返回true，则表示容器的根文件系统是以只读方式安装的。如果以上命令返回false，则表示该容器的根系统是可写的。,"在容器的运行时添加一个--read-only标志，以强制将容器的根文件系统挂载为只读。docker run <运行参数> --read-only <容器镜像名称或ID> <命令>。在容器的运行时启用--read-only选项应该由管理员使用，以强制容器的可执行进程只将容器数据写入显式存储位置，在容器的运行时期间。在容器运行时期间显式存储位置的示例包括但不限于：1.使用--tmpfs选项挂载临时文件系统以进行非持久性数据写入。docker run --interactive --tty --read-only --tmpfs ""/run"" --tmpfs ""/tmp"" centos /bin/bash。2.在容器的运行时启用Docker rw挂载，以将容器数据直接持久保存在Docker主机文件系统中。docker run --interactive --tty --read-only -v /opt/app/data:/run/app/data:rw centos /bin/bash。3.利用Docker共享存储卷插件，将Docker数据卷用于容器数据持久性。docker volume create -d convoy --opt o=size=20GB my-named-volume docker run --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash。4.在容器的运行时期间传输容器数据到Docker外部，以使容器数据持久保存。示例包括托管的数据库、网络文件共享和API。","http://docs.docker.com/reference/commandline/cli/#run,https://docs.docker.com/engine/tutorials/dockervolumes/,http://www.projectatomic.io/blog/2015/12/making-docker-images-write-only-in-production/,https://docs.docker.com/engine/reference/commandline/run/#mount-tmpfs-tmpfs,https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container"
5.13,5.13,容器运行时,确保容器入站流量绑定到特定的主机接口（Scored）,默认情况下，Docker容器可以连接到外部世界，但外部世界无法连接到容器。每个出站连接看起来都是来自主机的一个IP地址。只允许通过主机机器上的特定外部接口联系容器服务。,通过执行以下命令列出容器的所有正在运行的实例及其端口映射：`docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'` 查看列表，确保暴露的容器端口绑定到特定接口，而不是绑定到通配符IP地址 0.0.0.0。,将容器端口绑定到所需的主机端口上的特定主机接口。例如，docker run --detach --publish 10.2.3.4:49153:80 nginx。在上面的示例中，容器端口80绑定到49153号主机端口，仅接受来自10.2.3.4外部接口的传入连接。,https://docs.docker.com/engine/userguide/networking/
5.14,5.14,容器运行时,确保 'on-failure' 容器重启策略设置为 '5'（Scored）,通过在docker run命令中使用--restart标志，您可以为容器指定重启策略，以指定容器在退出时应该或不应该重新启动。您应该选择on-failure重启策略并将重启尝试限制为5次。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: RestartPolicyName={{ .HostConfig.RestartPolicy.Name }} MaximumRetryCount={{ .HostConfig.RestartPolicy.MaximumRetryCount }}'` 如果上述命令返回 RestartPolicyName=always，则系统未按要求配置，因此此建议不符合要求。如果上面的命令返回 RestartPolicyName=no 或仅返回 RestartPolicyName=，则不使用重新启动策略，容器将永远不会自行重新启动。因此，该建议不适用，可以认为是符合要求的。如果上面的命令返回 RestartPolicyName=on-failure，则通过查看 MaximumRetryCount 来验证重新启动尝试的次数是否设置为5次或更少。,如果希望容器自行重新启动，可以像以下这样启动容器：docker run --detach --restart=on-failure:5 nginx。,https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart
5.15,5.15,容器运行时,确保主机的进程命名空间未共享（Scored）,进程ID（PID）命名空间可以隔离进程ID编号空间，这意味着不同PID命名空间中的进程可以具有相同的PID。这是容器和主机之间的进程级隔离。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidMode={{ .HostConfig.PidMode }}'` 如果上面的命令返回host，则意味着主机PID命名空间与容器共享，否则符合此建议。,请勿使用--pid=host参数启动容器。例如，不要像下面这样启动容器：docker run --interactive --tty --pid=host centos /bin/bash。,https://docs.docker.com/engine/reference/run/#pid-settings-pid
5.16,5.16,容器运行时,确保主机的IPC命名空间未被共享（Scored）,IPC (POSIX/SysV IPC) 命名空间提供了命名的共享内存段、信号量和消息队列的隔离。因此，在主机上，IPC 命名空间不应与容器共享，应保持隔离。,"`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: IpcMode={{ .HostConfig.IpcMode }}'` 如果上面的命令返回host，则表示主机IPC命名空间与容器共享, 不符合要求。如果上面的命令什么也不返回，那么主机的IPC命名空间就不共享, 符合要求。",请勿使用--ipc=host参数启动容器。例如，不要像下面这样启动容器：docker run --interactive --tty --ipc=host centos /bin/bash。,https://docs.docker.com/engine/reference/run/#ipc-settings-ipc
5.17,5.17,容器运行时,确保主机设备不会直接暴露给容器 (Not Scored),在运行时，可以将主机设备直接暴露给容器。不要直接将主机设备暴露给容器，特别是对于不受信任的容器。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Devices={{ .HostConfig.Devices }}'` 上述命令将列出每个设备，并提供以下信息： CgroupPermissions - 例如，rwm；PathInContainer - 容器内的设备路径; PathOnHost - 主机上的设备路径; 验证是否需要从容器中访问主机设备，以及是否正确设置了所需的权限。如果上面的命令返回[]，则容器无法访问主机设备。可以认为该建议是符合要求的。,"请勿直接将主机设备暴露给容器。如果必须暴露主机设备给容器，则需要使用正确的权限设置。例如，不要按以下方式启动容器：

docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rwm --device=/dev/temp_sda:/dev/temp_sda:rwm centos bash

相反，应使用正确的权限设置共享主机设备，例如：

docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rw --device=/dev/temp_sda:/dev/temp_sda:r centos bash",https://docs.docker.com/engine/reference/commandline/run/#options
5.18,5.18,容器运行时,保证默认的 ulimit 在运行时被覆盖，仅在需要时进行（Not Scored）,默认ulimit设置在Docker守护进程级别。但是，在容器运行时，如果需要，您可以覆盖默认ulimit设置。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Ulimits={{ .HostConfig.Ulimits }}'` 上面的命令应该为每个容器实例返回 Ulimits=<no value>，直到出现异常并且需要重写默认的ulimit设置。,只有在必要的情况下才覆盖默认的ulimit设置。例如，要覆盖默认的ulimit设置，请按以下方式启动容器： docker run --ulimit nofile=1024:1024 --interactive --tty centos /bin/bash,https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-in-container-ulimit
5.19,5.19,容器运行时,确保未将挂载传播模式设置为共享（Scored）,挂载传播模式允许在容器上以共享、从属或私有模式挂载卷。在没有必要的情况下不要使用共享挂载传播模式。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Propagation={{range $mnt := .Mounts}} {{json $mnt.Propagation}} {{end}}'` 上面的命令将返回已挂载卷的 Propagation 模式。除非需要，否则不应将 Propagation 模式设置为 shared。如果没有挂载(mount)，上述命令可能会引发错误。在这种情况下，本建议不适用。,"请勿将卷挂载为共享模式传播。例如，不要像下面这样启动容器：
docker run <运行参数> --volume=/hostPath:/containerPath:shared <容器镜像名称或ID> <命令>。","https://github.com/docker/docker/pull/17034,https://docs.docker.com/engine/reference/run/#volume-shared-filesystems,https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt"
5.2,5.2,容器运行时,确保主机的UTS名称空间未共享（Scored）,UTS命名空间提供了两个系统标识符的隔离：主机名和NIS域名。它被用于设置在该命名空间中运行的进程可见的主机名和域名。在容器内运行的进程通常不需要知道主机名和域名。因此，该命名空间不应与主机共享。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UTSMode={{ .HostConfig.UTSMode }}'` 如果上面的命令返回host，则意味着主机UTS命名空间与容器共享，不符合要求。如果上面的命令什么也不返回，那么主机的UTS命名空间就不共享了，符合要求。,请勿使用 --uts=host 参数启动容器。例如，不要按以下方式启动容器：docker run --rm --interactive --tty --uts=host rhel7.2,https://docs.docker.com/engine/reference/run/#uts-settings-uts
5.21,5.21,容器运行时,确保默认的 seccomp 服务配置文件未被禁用（Scored）,Seccomp过滤器为进程提供了一种指定传入系统调用过滤器的方法。默认Docker的Seccomp配置基于白名单，并允许311个系统调用，拒绝其他所有调用。除非它妨碍了您的容器应用程序的使用，否则不应将其禁用。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'` 上述命令应返回＜no value＞或您修改后的seccomp配置文件。如果它返回[seccomp:unconfined]，则意味着此建议不符合要求，并且容器在没有任何seccomp配置文件的情况下运行。,默认情况下，seccomp配置文件已启用。除非您想要修改并使用修改后的seccomp配置文件，否则无需进行任何操作。,"https://docs.docker.com/engine/reference/run/#security-configuration,https://github.com/docker/docker/blob/master/profiles/seccomp/default.json,https://docs.docker.com/engine/security/seccomp/,https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt,https://github.com/docker/docker/issues/22870"
5.22,5.22,容器运行时,确保不使用特权选项执行docker exec命令（Scored）,请勿使用 --privileged 选项进行 docker exec。,如果按照第1节的规定启用了审核，则可以使用以下命令筛选出使用--privileged选项的docker exec命令: `ausearch -k docker | grep exec | grep privileged`,请勿在docker exec命令中使用--privileged选项。,https://docs.docker.com/engine/reference/commandline/exec/
5.23,5.23,容器运行时,确保不使用带有user=root选项的docker exec命令（Scored）,请勿使用--user选项进行Docker exec操作。,如果按照第1节的规定启用了审核，则可以使用以下命令筛选出使用 --user 选项的docker exec命令 `ausearch -k docker | grep exec | grep user`,请勿在docker exec命令中使用--user选项。,https://docs.docker.com/engine/reference/commandline/exec/
5.24,5.24,容器运行时,确保确认cgroup的使用情况（Scored）,在容器运行时，有可能与特定的cgroup关联。确认cgroup的使用可以确保容器在定义的cgroup下运行。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CgroupParent={{ .HostConfig.CgroupParent }}'` 上述命令将返回运行容器的cgroup。如果为空，则表示容器在默认的docker cgroup下运行。在这种情况下，这一建议是符合要求的。如果发现容器在cgroup下运行，而不是预期的cgroup，则此建议不符合要求。,除非必要，否则不要在docker run命令中使用--cgroup-parent选项。,"https://docs.docker.com/engine/reference/run/#specify-custom-cgroups,https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html"
5.25,5.25,容器运行时,确保容器不会获取额外的权限（Scored）,限制容器通过suid或sgid位获取额外的权限。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'` 上面的命令应该返回当前为容器配置的所有安全选项。no-new-privileges 也应该是其中之一。,例如，您应该按如下方式启动您的容器：docker run --rm -it --security-opt=no-new-privileges ubuntu bash。,"https://github.com/projectatomic/atomic-site/issues/269,https://github.com/docker/docker/pull/20727,https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt,https://lwn.net/Articles/475678/,https://lwn.net/Articles/475362/"
5.26,5.26,容器运行时,保证容器在运行时进行健康检查 （Scored）,如果容器镜像没有定义HEALTHCHECK指令，则应在容器运行时使用--health-cmd参数来检查容器的健康状况。,运行以下命令并确保所有容器都报告健康的运行状况： `docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Health={{ .State.Health.Status }}'`,运行容器时使用--health-cmd和其他参数。例如，docker run -d --health-cmd='stat /etc/passwd || exit 1' nginx。,https://docs.docker.com/engine/reference/run/#healthcheck
5.27,5.27,容器运行时,确保docker命令始终获得最新版本的镜像（Not Scored）,请始终确保使用仓库中最新的镜像版本，而不是缓存的旧版本。这有助于保证您获取的是最新内容。,步骤1：打开您的镜像仓库，列出您正在检查的镜像的版本历史。步骤2：观察 docker pull 命令触发时的状态。如果状态显示为image is update，则意味着您正在获取镜像的缓存版本。步骤3：将您正在运行的镜像版本与存储库中报告的最新版本相匹配如果您正在运行缓存的版本或最新的副本，则返回els。,请使用正确的版本固定机制（默认分配的最新标记仍然容易受到缓存攻击的影响），以避免提取缓存的旧版本。版本固定机制应用于基础镜像、软件包和整个镜像。您可以根据自己的需求自定义版本固定规则。,https://github.com/docker/docker/pull/16609
5.28,5.28,容器运行时,确保使用进程ID控制组限制（Scored）,请在容器运行时使用--pids-limit标志。,`运行以下命令并确保PidsLimit未设置为0或-1。PidsLimit为0或-1意味着可以在容器内同时 forked 任意数量的进程。 docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidsLimit={{ .HostConfig.PidsLimit }}'`,在启动容器时使用--pids-limit标志，并设置适当的值。例如，docker run -it --pids-limit 100 <Image_ID>。在上面的示例中，设置了允许同时运行的进程数量为100个。达到100个并发运行进程的限制后，docker会限制任何新的进程创建。,"https://github.com/docker/docker/pull/18697,https://docs.docker.com/engine/reference/commandline/run/#options"
5.29,5.29,容器运行时,确保 Docker 默认的桥接网络 docker0 没有被使用（Not Scored）,不要使用Docker的默认bridge docker0，使用Docker的用户定义网络来进行容器网络连接。,运行以下命令，并验证容器是否位于用户定义的网络上，而不是默认的docker0网桥上: `docker network ls --quiet | xargs xargs docker network inspect --format '{{ .Name }}: {{ .Options }}'`,请遵循Docker文档并设置用户定义的网络。在该定义的网络中运行所有容器。,"https://github.com/nyantec/narwhal,https://arxiv.org/pdf/1501.02967,https://docs.docker.com/engine/userguide/networking/"
5.3,5.3,容器运行时,确保不共享主机的用户命名空间（Scored）,不要与容器共享主机的用户命名空间。,运行以下命令并确保它不会返回任何 UsernsMode 值。如果它返回值host，则意味着主机用户命名空间与容器共享。`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UsernsMode={{ .HostConfig.UsernsMode }}'`,"不要在主机和容器之间共享用户名称空间。例如，不要像下面这样运行容器：
docker run --rm -it --userns=host ubuntu bash","https://docs.docker.com/engine/security/userns-remap/,https://docs.docker.com/engine/reference/commandline/run/#options,https://github.com/docker/docker/pull/12648,https://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces"
5.31,5.31,容器运行时,确保Docker套接字未挂载在任何容器内（Scored）,不应该将Docker套接字docker.sock挂载到容器内部。,`docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}' | grep docker.sock` 上面的命令将返回docker.sock作为卷映射到容器的任何实例。,请确保没有容器将docker.sock挂载为一个卷。,"https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/,https://forums.docker.com/t/docker-in-docker-vs-mounting-var-run-docker-sock/9450/2,https://github.com/docker/docker/issues/21109"
6.1,6.1,Docker 安全运维,确保避免镜像扩散（Not Scored）,不要在同一主机上保存大量的容器镜像。适当使用标记的镜像。,步骤1：通过执行以下命令列出当前实例化的所有镜像ID：`docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'` 步骤2：通过执行下面的命令列出系统上存在的所有镜像：`docker images`,请保留您实际需要的图片集，并建立一个工作流程来从主机中删除旧或过期的镜像。此外，使用拉取摘要等功能从注册表获取特定镜像。此外，您可以按照下列步骤查找系统中未使用的镜像并将其删除。 **步骤1** 通过执行以下命令，列出当前由docker实例化的所有镜像ID清单： docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'  **步骤2** ：通过执行以下命令，列出系统中所有的镜像： docker images  **步骤3** ：比较从步骤1和步骤2中产生的镜像ID列表，并找出当前未实例化的镜像。  **步骤4** ：决定是否要保留未使用的镜像，如果不需要，则通过执行以下命令将其删除： docker rmi $IMAGE_ID,"https://forums.docker.com/t/command-to-remove-all-unused-images/20/8,https://github.com/docker/docker/issues/9054,https://docs.docker.com/engine/reference/commandline/rmi/,https://docs.docker.com/engine/reference/commandline/pull/,https://github.com/docker/docker/pull/11109"
6.2,6.2,Docker 安全运维,确保避免容器蔓延（Not Scored）,请勿在同一台主机上保留大量容器。,步骤1-查找主机上的容器总数：`docker info --format '{{ .Containers }}` 步骤2-执行以下命令以查找主机上实际正在运行或处于停止状态的容器总数。`docker info --format '{{ .ContainersStopped }}'; docker info --format '{{ .ContainersRunning }}'`如果在主机上停止的容器数量与实际在主机上运行的容器数量之间的差异很大（比如说25个或更多），那么可能是容器在主机上蔓延了。,定期检查每个主机中的容器清单，并使用以下命令清理已停止的容器：docker container prune。,https://zeltser.com/security-risks-and-benefits-of-docker-application/
7.1,7.1,Docker Swarm 配置,请确保不要在非必要情况下启用Swarm模式，以确保系统安全（Scored）,除非必要，不要在Docker引擎实例上启用Swarm模式。,查看docker info命令的输出。如果输出包括Swarm:active，则表明docker引擎上的Swarm模式已被激活。确认docker引擎实例上是否确实需要Swarm模式。,如果系统错误地启用了 Swarm 模式，请执行  docker swarm leave 命令退出。,https://docs.docker.com/engine/reference/commandline/swarm_init/
7.2,7.2,Docker Swarm 配置,确保在Swarm中创建了最少数量的管理节点（Scored）,确保在Swarm中创建了最少数量所需的管理节点。,运行docker info并验证管理器的数量。`docker info --format '{{ .Swarm.Managers }}' '。或者运行以下命令。`docker node ls | grep 'Leader',如果配置了过多的管理者，可以使用以下命令将多余的管理者降级为工作节点: docker node demote <ID>，其中<ID>是需要降级的管理者的节点ID。,"https://docs.docker.com/engine/swarm/manage-nodes/,https://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-for-fault-tolerance"
7.3,7.3,Docker Swarm 配置,确保Swarm服务绑定到特定的主机接口（Scored）,默认情况下，Docker Swarm服务将监听主机上的所有接口，对于主机具有多个网络接口并不一定必要。,列出端口2377TCP上的网络侦听器（docker swarm的默认值），并确认它只在特定接口上侦听。例如，使用ubuntu可以通过以下命令完成：`netstat -lt | grep -i 2377`,“修复这个问题需要重新初始化 swarm，指定特定的接口给 --listen-addr 参数。”,"https://docs.docker.com/engine/reference/commandline/swarm_init/#--listen-addr,https://docs.docker.com/engine/swarm/admin_guide/#recover-from-disaster"
7.4,7.4,Docker Swarm 配置,确保容器间在叠加网络的不同节点上进行数据交换时进行加密（Scored）,在覆盖网络上不同节点之间的容器之间加密交换的数据。,运行以下命令并确保每个覆盖网络都已加密`docker network ls --filter driver=overlay --quiet | xargs docker network inspect --format '{{.Name}} {{ .Options }}'`,使用 --opt encrypted 标志创建叠加网络。,"https://docs.docker.com/engine/userguide/networking/overlay-security-model/,https://github.com/docker/docker/issues/24253"
7.5,7.5,Docker Swarm 配置,确保在Swarm集群中管理秘密时，使用Docker的秘密管理命令（Not Scored）,请使用Docker内置的秘密管理命令。,在swarm管理器节点上，运行以下命令，并确保在您的环境中使用docker机密管理（如果适用）`docker secret ls`,遵循Docker机密文档并使用它来有效地管理机密。,https://docs.docker.com/engine/reference/commandline/secret/
7.6,7.6,Docker Swarm 配置,确保Swarm管理器以自动锁定模式运行（Scored）,在自动锁定模式下运行 Docker Swarm 管理器。,运行以下命令。如果它输出密钥，则表示swarm已使用--autolock标志初始化。如果输出为未设置解锁密钥，则表明swarm未使用--autolockflag初始化，不符合此建议。 `docker swarm unlock-key` ,如果你正在初始化一个swarm，使用下面的命令：docker swarm init --autolock。如果你想在现有的swarm管理节点上设置--autolock，使用下面的命令：docker swarm update --autolock。,https://docs.docker.com/engine/swarm/swarm_manager_locking/
7.7,7.7,Docker Swarm 配置,确保Swarm Manager自动锁定密钥定期轮换（Not Scored）,定期轮换Swarm管理器自动锁定密钥。,运行以下命令以旋转关键点`docker swarm unlock-key --rotate`。此外，为了便于对该建议进行审计，请维护密钥轮换记录，并确保您为密钥轮换建立预定义的频率。,运行以下命令来旋转密钥。 docker swarm unlock-key --rotate 此外，为了方便审计此建议，请维护密钥旋转记录，并确保建立预定的密钥旋转频率。,https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/
7.8,7.8,Docker Swarm 配置,确保适当地轮换节点证书（Not Scored）,根据需要更换Swarm节点证书。,"运行以下命令，并确保节点证书到期持续时间设置为适当。`docker info | grep ""Expiry Duration""`",执行以下命令以设置所需的到期时间。例如，docker swarm update --cert-expiry 48h。,https://docs.docker.com/engine/reference/commandline/swarm_update/#exampl
7.9,7.9,Docker Swarm 配置,确保适当轮换CA证书（Not Scored）,根据需要旋转根CA证书。,根据您的安装路径，检查根CA证书文件上的时间戳。例如， `ls -l /var/lib/docker/swarm/certificates/swarm-root-ca.crt`，证书应该按照既定的频率轮换。,运行以下命令以旋转证书。 docker swarm ca --rotate,https://docs.docker.com/engine/swarm/how-swarm-mode-works/pki/#rotating-the-ca-certificate
7.1,7.1,Docker Swarm 配置,请确保管理平面流量已经与数据平面流量分离（Not Scored）,将管理平面流量与数据平面流量分开。,在每个swarm节点上运行以下命令，并确保管理平面地址与数据平面地址不同。 `docker node inspect --format '{{ .Status.Addr }}' self` 注意：在编写此基准时，无法检查数据平面地址。已提出一个问题，该问题位于参考链接中。,请用以下方式初始化Swarm：专门为管理和数据平面分别设置接口。例如，docker swarm init --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3。,"https://docs.docker.com/engine/reference/commandline/swarm_init/#--data-path-addr,https://github.com/moby/moby/issues/33938,https://github.com/moby/moby/pull/32717"
